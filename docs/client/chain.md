# Lean Consensus Experimental Chain
<!-- mdformat-toc start --slug=github --no-anchors --maxlevel=6 --minlevel=2 -->

- [Introduction](#introduction)
- [Configuration](#Configuration)
  - [Time parameters](#Time parameters)
- [Presets](#Presets)
- [Genesis](#genesis)
  - [Genesis state](#genesis-state)
  - [Genesis block](#genesis-block)
- [STF](#STF)

<!-- mdformat-toc end -->

## Introduction

This document specs the behavior and functionality of the lean chain. This is a minimal chain spec to prepare the lean clients to be ready for post quantum signature devnets with the following features:

| Devnet | Purpose                    | ETA |
| ------ | -------                    | :-: |
| 0      | pq signature preparation   | Oct 2025 |


### Devnet 0 Functionality

1. Chain-ing
  This is beacon style chaining via latest_block_header in state verified against parent hash of the new block. LMD-Ghost (without application of beacon chain style filter block tree)
2. 3SF mini justification & finalization
  Departing from the beacon chain epoch centric processing, the lean chain employs a slightly translated version of the 3SF mini where all validators vote every slot.
3. Empty signatures
  Since we will be moving to post quantum signatures `Devnet1` onwards, `Devnet0` data is generated with zero bytes signatures with no signature verification involved. This means voting is a trusted process where the client creates a vote as per their assigned validators.
4. No Aggregation
  The votes casted in the network are simply consumed and packed without aggregation. Beacon style aggregation will be introduced in the Devnet 2.
5. Round robin proposals
  The proposal assignment process has also been kept simple to just assign the proposals based on a round robin process based on the validator index. This makes proposal also a trusted process where the client proposes a block as per their assigned validators.
5. Simplified Validators
  There is no validator deposit, activation, withdrawal or slashing making the validator lifecyle super simple. Each validator has the weight of `1` and since validators don't even generate signatures, there is no validator tracking in the state. Validators are assigned to the clients based on a config file.

## Configuration

### Time parameters

| Name                                  | Value                     |     Unit     |   Duration    |
| ------------------------------------- | ------------------------- | :----------: | :-----------: |
| `SLOT_DURATION_MS`                    | `uint64(4000)`            | milliseconds | 4 seconds     |
| `INTERVALS_PER_SLOT`                  | `uint64(4)`               | intervals    | 1 second      |

## Presets

### State list lengths

| Name                           | Value                                 |       Unit       |   Duration    |
| ------------------------------ | ------------------------------------- | :--------------: | :-----------: |
| `HISTORICAL_ROOTS_LIMIT`       | `uint64(2**18)` (= 262,144)           | historical roots |   12.1 days   |
| `VALIDATOR_REGISTRY_LIMIT`     | `uint64(2**12)` (= 4,096)             |    validators    |               |

## Genesis

The genesis for lean devnets especially `Devnet0` is rather simple. This can even be generated by clients locally:
Let `genesis_state = generate_genesis_state(genesis_time, num_validators)`
where:
 - `genesis_time` is the configured time for the genesis slot
 - `num_validators` is the configured number of validators to run the chain with

 Even though `Devnet0` has no individual validators tracking, there would also be no need for `genesis_validators_root` going further as well because the state and hence state root would already encode the genesis validator's array.

### Genesis state

```python
def generate_genesis_state(genesis_time: uint64, num_validators: uint64) -> State {
  state = State(
    config=Config(
      genesis_time=genesis_time,
      num_validators=num_validators,
    ),
    latest_block_header=BlockHeader(body_root=hash_tree_root(BeaconBlockBody())),
  );

  return state;
}
```

### Genesis block

Let `genesis_block = Block(state_root=hash_tree_root(genesis_state))`.

## STF

The state transition function follows on the lines of beacon chain STF except that there is no epoch processing. Furthermore to keep the STF prover friendly, all signatures in the block whether its signed block signature or signed votes signatures, will be verified outside the STF with a boolean flag `valid_signatures` to STF indicating the successful verification (or not) of all signatures in the block.

The post-state corresponding to a pre-state `state` and a signed block
`signed_block` is defined as `state_transition(state, signed_block)`. State
transitions that trigger an unhandled exception (e.g. a failed `assert` or an
out-of-range list access) are considered invalid. State transitions that cause a
`uint64` overflow or underflow are also considered invalid.

```python
def state_transition(
    state: State, signed_block: SignedBlock, valid_signatures: bool, validate_result: bool = True
) -> None:
    # Verify signatures
    assert valid_signatures == True

    block = signed_block.message
    # Process slots (including those with no blocks) since block
    process_slots(state, block.slot)
    # Process block
    process_block(state, block)
    # Verify state root
    if validate_result:
        assert block.state_root == hash_tree_root(state)
```

```python
def process_slots(state: State, slot: Slot) -> None:
    assert state.slot < slot
    while state.slot < slot:
        process_slot(state)
        state.slot = Slot(state.slot + 1)
```

```python
def process_slot(state: BeaconState) -> None:
    # Cache latest block header state root
    if state.latest_block_header.state_root == Bytes32():
        previous_state_root = hash_tree_root(state)
        state.latest_block_header.state_root = previous_state_root
```

### Block processing

```python
def process_block(state: State, block: Block) -> None:
    process_block_header(state, block)
    process_operations(state, block.body)
```

#### Block header

```python
def process_block_header(state: State, block: Block) -> None:
    # Verify that the slots match
    assert block.slot == state.slot
    # Verify that the block is newer than latest block header
    assert block.slot > state.latest_block_header.slot
    # Verify that proposer index is the correct index
    assert block.proposer_index == block.slot % state.config.num_validators
    # Verify that the parent matches
    assert block.parent_root == hash_tree_root(state.latest_block_header)

    # If this was first block post genesis, 3sf mini special treatment is required
    # to correctly set genesis block root as already justified and finalized. 
    # This is not possible at the time of genesis state generation and are set at 
    # zero bytes because genesis block is calculated using genesis state causing a 
    # circular dependancy
    if(state.latest_block_header.slot == 0)
        # block.parent_root is the genesis root
        state.latest_justified.root = block.parent_root
        state.latest_finalized.root = block.parent_root

    # Cache current block as the new latest block
    state.latest_block_header = BeaconBlockHeader(
        slot=block.slot,
        proposer_index=block.proposer_index,
        parent_root=block.parent_root,
        state_root=Bytes32(),  # Overwritten in the next process_slot call
        body_root=hash_tree_root(block.body),
    )
```

#### Operations

```python
def process_operations(state: State, body: BlockBody) -> None:
    # process attestations/votes
    process_attestations(state, body.votes)
    # other operations will get added as the functionality evolves
```

```python
def process_attestations(state: State, votes: Vote[]) -> None:
    # From 3sf-mini/consensus.py
    # Construct already done justifications map from flattened justifications_roots and
    # justifications_validators ssz lists. Clients can maintain/track an in memory map
    # in normal operations as part of local state object and skip this step but this 
    # will still need to be generated while running STF in prover
    justifications = generate_justifications_map(state.justifications_roots, state.justifications_validators)

```
