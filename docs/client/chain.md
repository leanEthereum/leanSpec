# Lean Consensus Experimental Chain
<!-- mdformat-toc start --slug=github --no-anchors --maxlevel=6 --minlevel=2 -->

- [Introduction](#introduction)
- [Configuration](#Configuration)
  - [Time parameters](#Time parameters)
- [Presets](#Presets)
- [Genesis](#genesis)
  - [Genesis state](#genesis-state)
  - [Genesis block](#genesis-block)
- [STF](#STF)

<!-- mdformat-toc end -->

## Introduction

This document specs the behavior and functionality of the lean chain. This is a minimal chain spec to prepare the lean clients to be ready for post quantum signature devnets with the following features:

| Devnet | Purpose                    | ETA |
| ------ | -------                    | :-: |
| 0      | pq signature preparation   | Oct 2025 |


### Devnet 0 Functionality

1. Chain-ing
  This is beacon style chaining via latest_block_header in state verified against parent hash of the new block. LMD-Ghost (without application of beacon chain style filter block tree)
2. 3SF mini justification & finalization
  Departing from the beacon chain epoch centric processing, the lean chain employs a slightly translated version of the 3SF mini where all validators vote every slot.
3. Empty signatures
  Since we will be moving to post quantum signatures `Devnet1` onwards, `Devnet0` data is generated with zero bytes signatures with no signature verification involved. This means voting is a trusted process where the client creates a vote as per their assigned validators.
4. No Aggregation
  The votes casted in the network are simply consumed and packed without aggregation. Beacon style aggregation will be introduced in the Devnet 2.
5. Round robin proposals
  The proposal assignment process has also been kept simple to just assign the proposals based on a round robin process based on the validator index. This makes proposal also a trusted process where the client proposes a block as per their assigned validators.
5. Simplified Validators
  There is no validator deposit, activation, withdrawal or slashing making the validator lifecyle super simple. Each validator has the weight of `1` and since validators don't even generate signatures, there is no validator tracking in the state. Validators are assigned to the clients based on a config file.

## Configuration

### Time parameters

| Name                                  | Value                     |     Unit     |   Duration    |
| ------------------------------------- | ------------------------- | :----------: | :-----------: |
| `SLOT_DURATION_MS`                    | `uint64(4000)`            | milliseconds | 4 seconds     |
| `INTERVALS_PER_SLOT`                  | `uint64(4)`               | intervals    | 1 second      |

## Presets

### State list lengths

| Name                           | Value                                 |       Unit       |   Duration    |
| ------------------------------ | ------------------------------------- | :--------------: | :-----------: |
| `HISTORICAL_ROOTS_LIMIT`       | `uint64(2**18)` (= 262,144)           | historical roots |   12.1 days   |
| `VALIDATOR_REGISTRY_LIMIT`     | `uint64(2**12)` (= 4,096)             |    validators    |               |

## Genesis

The genesis for lean devnets especially `Devnet0` is rather simple. This can even be generated by clients locally:
Let `genesis_state = generate_genesis_state(genesis_time, num_validators)`
where:
 - `genesis_time` is the configured time for the genesis slot
 - `num_validators` is the configured number of validators to run the chain with

 Even though `Devnet0` has no individual validators tracking, there would also be no need for `genesis_validators_root` going further as well because the state and hence state root would already encode the genesis validator's array.

### Genesis state

```python
def generate_genesis_state(genesis_time: uint64, num_validators: uint64) -> State {
  state = State(
    config=Config(
      genesis_time=genesis_time,
      num_validators=num_validators,
    ),
    latest_block_header=BlockHeader(body_root=hash_tree_root(BeaconBlockBody())),
  );

  return state;
}
```

### Genesis block

Let `genesis_block = Block(state_root=hash_tree_root(genesis_state))`.

## STF

The state transition function follows on the lines of beacon chain STF except that there is no epoch processing. Furthermore to keep the STF prover friendly, all signatures in the block whether its signed block signature or signed votes signatures, will be verified outside the STF with a boolean flag `valid_signatures` to STF indicating the successful verification (or not) of all signatures in the block.

The post-state corresponding to a pre-state `state` and a signed block
`signed_block` is defined as `state_transition(state, signed_block)`. State
transitions that trigger an unhandled exception (e.g. a failed `assert` or an
out-of-range list access) are considered invalid. State transitions that cause a
`uint64` overflow or underflow are also considered invalid.

```python
def state_transition(
    state: State, signed_block: SignedBlock, valid_signatures: bool, validate_result: bool = True
) -> None:
    # Verify signatures
    assert valid_signatures == True

    block = signed_block.message
    # Process slots (including those with no blocks) since block
    process_slots(state, block.slot)
    # Process block
    process_block(state, block)
    # Verify state root
    if validate_result:
        assert block.state_root == hash_tree_root(state)
```